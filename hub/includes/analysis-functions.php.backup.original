<?php
/**
 * QuietGo AI Analysis Functions v3.1
 * Contains stool, meal, and symptom analysis functions
 * With format validation, transformation, and browser-visible debug
 */

/**
 * Validate CalcuPlate Response Format
 * Ensures all items have measurement_type field
 */
function validateCalcuPlateFormat($analysisData)
{
    $errors = [];

    if (!isset($analysisData['pass_1_detection'])) {
        $errors[] = 'Missing pass_1_detection';
        return ['valid' => false, 'errors' => $errors];
    }

    foreach ($analysisData['pass_1_detection'] as $itemName => $itemData) {
        if (!isset($itemData['measurement_type'])) {
            $errors[] = "$itemName missing measurement_type";
        } else {
            $type = $itemData['measurement_type'];

            // Validate required fields for each type
            switch ($type) {
                case 'count':
                    if (!isset($itemData['count'])) {
                        $errors[] = "$itemName (count type) missing count field";
                    }
                    break;

                case 'portion':
                    if (!isset($itemData['amount'])) {
                        $errors[] = "$itemName (portion type) missing amount field";
                    }
                    break;

                case 'weighted_protein':
                    if (!isset($itemData['protein_count']) || !isset($itemData['protein_weight'])) {
                        $errors[] = "$itemName (weighted_protein type) missing protein_count or protein_weight";
                    }
                    break;

                case 'beverage':
                    if (!isset($itemData['beverage_type']) || !isset($itemData['beverage_size'])) {
                        $errors[] = "$itemName (beverage type) missing beverage_type or beverage_size";
                    }
                    break;
            }
        }
    }

    return [
        'valid' => empty($errors),
        'errors' => $errors
    ];
}

/**
 * Transform Legacy Format to v3.0 Format
 * Converts old format (count/amount mixed) to new measurement_type format
 */
function transformLegacyFormat($analysisData)
{
    $transformLog = [];

    if (!isset($analysisData['pass_1_detection'])) {
        return [$analysisData, []];
    }

    $transformed = $analysisData;

    foreach ($analysisData['pass_1_detection'] as $itemName => $itemData) {
        // Skip if already has measurement_type
        if (isset($itemData['measurement_type'])) {
            continue;
        }

        // Infer measurement_type from available fields
        $newItemData = ['method' => $itemData['method'] ?? 'detected'];

        // Check for beverage indicators
        if (
            stripos($itemName, 'beverage') !== false ||
            stripos($itemName, 'cola') !== false ||
            stripos($itemName, 'soda') !== false ||
            stripos($itemName, 'water') !== false ||
            stripos($itemName, 'juice') !== false ||
            stripos($itemName, 'coffee') !== false ||
            stripos($itemName, 'tea') !== false
        ) {

            $newItemData['measurement_type'] = 'beverage';

            // Try to extract size from size/amount field
            if (isset($itemData['size'])) {
                $newItemData['beverage_size'] = $itemData['size'];
            } elseif (isset($itemData['amount'])) {
                $newItemData['beverage_size'] = $itemData['amount'];
            } else {
                $newItemData['beverage_size'] = '8 oz'; // Default
            }

            // Infer type from name
            if (stripos($itemName, 'cola') !== false || stripos($itemName, 'soda') !== false) {
                // Check if diet/zero mentioned
                if (stripos($itemName, 'diet') !== false || stripos($itemName, 'zero') !== false) {
                    $newItemData['beverage_type'] = 'soda_diet';
                } else {
                    $newItemData['beverage_type'] = 'soda_regular';
                }
            } elseif (stripos($itemName, 'water') !== false) {
                $newItemData['beverage_type'] = 'water';
            } elseif (stripos($itemName, 'coffee') !== false || stripos($itemName, 'tea') !== false) {
                $newItemData['beverage_type'] = 'coffee_black';
            } else {
                $newItemData['beverage_type'] = 'water'; // Safe default
            }

            $transformLog[] = "$itemName → beverage ({$newItemData['beverage_type']}, {$newItemData['beverage_size']})";

            // Check for protein indicators
        } elseif (
            stripos($itemName, 'salmon') !== false ||
            stripos($itemName, 'chicken') !== false ||
            stripos($itemName, 'steak') !== false ||
            stripos($itemName, 'fish') !== false ||
            stripos($itemName, 'pork') !== false ||
            stripos($itemName, 'beef') !== false
        ) {

            $newItemData['measurement_type'] = 'weighted_protein';
            $newItemData['protein_count'] = isset($itemData['count']) && is_numeric($itemData['count']) ? intval($itemData['count']) : 1;

            // Try to extract weight from amount or default
            if (isset($itemData['amount']) && preg_match('/(\d+)\s*oz/', $itemData['amount'], $matches)) {
                $newItemData['protein_weight'] = $matches[1] . ' oz';
            } else {
                $newItemData['protein_weight'] = '6 oz'; // Medium default
            }

            $transformLog[] = "$itemName → weighted_protein ({$newItemData['protein_count']} piece, {$newItemData['protein_weight']})";

            // Check if it has a numeric count
        } elseif (isset($itemData['count']) && is_numeric($itemData['count']) && $itemData['count'] > 0) {
            $newItemData['measurement_type'] = 'count';
            $newItemData['count'] = intval($itemData['count']);

            $transformLog[] = "$itemName → count ({$newItemData['count']})";

            // Check if it has an amount (volume)
        } elseif (isset($itemData['amount']) && !empty($itemData['amount'])) {
            $newItemData['measurement_type'] = 'portion';
            $newItemData['amount'] = $itemData['amount'];

            $transformLog[] = "$itemName → portion ({$newItemData['amount']})";

            // Default to portion with reasonable guess
        } else {
            $newItemData['measurement_type'] = 'portion';
            $newItemData['amount'] = '1/2 cup';

            $transformLog[] = "$itemName → portion (defaulted to 1/2 cup)";
        }

        $transformed['pass_1_detection'][$itemName] = $newItemData;
    }

    return [$transformed, $transformLog];
}

/**
 * Analyze Stool Photo using Bristol Stool Scale
 */
function analyzeStoolPhoto($imagePath, $journeyConfig, $symptoms, $time, $notes)
{
    error_log("QuietGo: analyzeStoolPhoto called for: $imagePath");

    $base64Image = encodeImageForOpenAI($imagePath);
    if (!$base64Image) {
        error_log("QuietGo ERROR: Failed to encode image for stool analysis");
        throw new Exception('Failed to process image for AI analysis');
    }

    error_log("QuietGo: Image encoded successfully, preparing AI request");

    $systemPrompt = "You are a professional digestive health AI assistant specialized in Bristol Stool Scale analysis.

Analyze this stool photo and provide insights using {$journeyConfig['tone']} focused on {$journeyConfig['focus']}.

Please respond ONLY with a valid JSON object containing:
{
    \"bristol_scale\": (1-7 number),
    \"bristol_description\": \"Type X: Description\",
    \"color_assessment\": \"color description\",
    \"consistency\": \"hard/normal/loose\",
    \"volume_estimate\": \"small/normal/large\",
    \"confidence\": (70-95 number),
    \"health_insights\": [\"insight1\", \"insight2\", \"insight3\"],
    \"recommendations\": [\"rec1\", \"rec2\", \"rec3\"]
}

Context provided:";

    $userPrompt = "Time: $time
Symptoms: $symptoms
Notes: $notes

Analyze this stool photo using the Bristol Stool Scale and provide {$journeyConfig['recommendations']}.";

    $messages = [
        [
            'role' => 'system',
            'content' => $systemPrompt
        ],
        [
            'role' => 'user',
            'content' => [
                [
                    'type' => 'text',
                    'text' => $userPrompt
                ],
                [
                    'type' => 'image_url',
                    'image_url' => [
                        'url' => $base64Image,
                        'detail' => 'high'
                    ]
                ]
            ]
        ]
    ];

    $response = makeOpenAIRequest($messages, OPENAI_VISION_MODEL, 800);

    error_log("QuietGo: OpenAI response received. Has error: " . (isset($response['error']) ? 'YES - ' . $response['error'] : 'NO'));

    if (isset($response['error'])) {
        error_log("QuietGo ERROR: " . $response['error']);
        throw new Exception($response['error']);
    }

    $aiContent = $response['choices'][0]['message']['content'];
    error_log("QuietGo: AI content length: " . strlen($aiContent));

    // Strip markdown code blocks if present
    $aiContent = preg_replace('/^```json\s*/m', '', $aiContent);
    $aiContent = preg_replace('/\s*```$/m', '', $aiContent);
    $aiContent = trim($aiContent);

    $analysisData = json_decode($aiContent, true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        error_log("QuietGo Stool Analysis JSON Error: " . json_last_error_msg());
        error_log("AI Response: " . $aiContent);
        throw new Exception('Invalid AI response format');
    }

    error_log("QuietGo: Stool analysis parsed successfully. Bristol: " . ($analysisData['bristol_scale'] ?? 'NULL') . ", Confidence: " . ($analysisData['confidence'] ?? 'NULL'));

    // Add metadata
    $analysisData['timestamp'] = time();
    $analysisData['ai_model'] = OPENAI_VISION_MODEL;
    $analysisData['reported_symptoms'] = $symptoms ?: null;
    $analysisData['correlation_note'] = $symptoms ? 'Symptoms logged for pattern analysis' : null;

    return $analysisData;
}

/**
 * Analyze Meal Photo with CalcuPlate AI v3.1 (with validation + transformation + debug)
 */
function analyzeMealPhotoWithCalcuPlate($imagePath, $journeyConfig, $symptoms, $time, $notes)
{
    error_log("QuietGo CalcuPlate v3.1: Starting analysis for: $imagePath");

    $base64Image = encodeImageForOpenAI($imagePath);
    if (!$base64Image) {
        error_log("QuietGo CalcuPlate ERROR: Failed to encode image");
        throw new Exception('Failed to process image for AI analysis');
    }

    error_log("QuietGo CalcuPlate: Image encoded successfully, preparing v3.1 prompt");

    $systemPrompt = "You are CalcuPlate v3.1 - A professional meal analysis AI with STRICT output formatting requirements.

=== CRITICAL FORMAT REQUIREMENT ===
EVERY food item MUST include a \"measurement_type\" field.
NO EXCEPTIONS. This field is MANDATORY.

Valid measurement_type values:
- \"count\" (for countable items)
- \"portion\" (for volume-based foods)
- \"weighted_protein\" (for proteins with size estimates)
- \"beverage\" (for all liquids)

=== YOUR MISSION ===
1. Scan ENTIRE image (center, edges, background)
2. Identify ALL visible food/beverage items
3. Categorize each by measurement_type
4. Provide accurate quantities
5. Ignore backgrounds, plates, utensils, decorations

=== DECISION TREE (USE THIS FOR EVERY ITEM) ===

FOR EACH VISIBLE ITEM:

STEP 1: What is it?
→ Identify the specific food/beverage

STEP 2: Is it a beverage/liquid?
YES → measurement_type: \"beverage\"
      REQUIRED FIELDS:
      - beverage_type: water/soda_regular/soda_diet/coffee_black/coffee_cream/juice/milk_whole/milk_2percent/milk_skim/alcohol_beer/alcohol_wine/alcohol_spirits
      - beverage_size: \"8 oz\", \"12 oz\", \"16 oz\", etc.
      EXAMPLE:
      \"cola\": {
        \"measurement_type\": \"beverage\",
        \"beverage_type\": \"soda_regular\",
        \"beverage_size\": \"12 oz\",
        \"method\": \"standard can size\"
      }

NO → Continue to STEP 3

STEP 3: Is it a whole protein (chicken, fish, steak, pork chop)?
YES → measurement_type: \"weighted_protein\"
      REQUIRED FIELDS:
      - protein_count: 1, 2, 3, etc.
      - protein_weight: \"3 oz\", \"6 oz\", \"8 oz\", etc.
      EXAMPLE:
      \"salmon\": {
        \"measurement_type\": \"weighted_protein\",
        \"protein_count\": 1,
        \"protein_weight\": \"6 oz\",
        \"method\": \"1 fillet sliced for presentation\"
      }

NO → Continue to STEP 4

STEP 4: Is it whole, discrete, AND countable (visible count <20)?
YES → measurement_type: \"count\"
      REQUIRED FIELDS:
      - count: numeric value
      EXAMPLES:
      - Whole olives → count
      - Whole cherry tomatoes on the side → count
      - Eggs with visible yolks → count

NO → Continue to STEP 5

STEP 5: Is it chopped, mixed into a dish, or volume-based?
YES → measurement_type: \"portion\"
      REQUIRED FIELDS:
      - amount: \"1/4 cup\", \"1/2 cup\", \"1 cup\", \"2 tbsp\", etc.
      EXAMPLES:
      - Chopped tomatoes MIXED IN → portion (\"1/4 cup chopped\")
      - Rice, quinoa, pasta → portion
      - Peas, corn, beans → portion (NEVER count individuals)
      - Leafy greens → portion
      - Ground/shredded meat → portion
      - Crumbled cheese → portion
      - Sauces, dressings → portion

=== CRITICAL EXAMPLES ===

CHOPPED VEGETABLES IN SALAD/BOWL:
❌ WRONG: \"cherry_tomatoes\": {\"measurement_type\": \"count\", \"count\": 5}
✓ CORRECT: \"tomatoes_chopped\": {\"measurement_type\": \"portion\", \"amount\": \"1/4 cup\", \"method\": \"diced tomatoes mixed throughout dish\"}

WHY: If tomatoes are chopped and mixed into the dish, they're PORTION-based, not countable.
ONLY count cherry tomatoes if they're whole and sitting on the side as garnish.

WHOLE CHERRY TOMATOES ON SIDE:
✓ CORRECT: \"cherry_tomatoes\": {\"measurement_type\": \"count\", \"count\": 3, \"method\": \"whole cherry tomatoes as garnish\"}

COLA/SODA:
❌ WRONG: \"cola\": {\"amount\": \"12 oz\", \"method\": \"standard glass size\"}
✓ CORRECT: \"cola\": {\"measurement_type\": \"beverage\", \"beverage_type\": \"soda_regular\", \"beverage_size\": \"12 oz\", \"method\": \"standard can size\"}

SALMON (SLICED FOR PRESENTATION):
❌ WRONG: \"salmon\": {\"count\": 5} (would be 5x calories!)
✓ CORRECT: \"salmon\": {\"measurement_type\": \"weighted_protein\", \"protein_count\": 1, \"protein_weight\": \"6 oz\", \"method\": \"1 fillet sliced decoratively\"}

QUINOA/RICE/GRAINS:
✓ CORRECT: \"quinoa\": {\"measurement_type\": \"portion\", \"amount\": \"1 cup\", \"method\": \"visual volume estimate\"}

GREEN BEANS (PILED):
✓ CORRECT: \"green_beans\": {\"measurement_type\": \"portion\", \"amount\": \"1/2 cup\", \"method\": \"visual estimate of whole beans\"}

FETA CHEESE (CRUMBLED):
✓ CORRECT: \"feta_cheese\": {\"measurement_type\": \"portion\", \"amount\": \"2 tbsp\", \"method\": \"estimated crumbled cheese\"}

OLIVES (WHOLE, VISIBLE):
✓ CORRECT: \"olives\": {\"measurement_type\": \"count\", \"count\": 4, \"method\": \"counted whole olives\"}

=== MANDATORY OUTPUT FORMAT ===

{
  \"pass_1_detection\": {
    \"item_1\": {
      \"measurement_type\": \"REQUIRED\",
      [type-specific fields],
      \"method\": \"how you determined this\"
    }
  },
  \"pass_2_verification\": {
    \"item_1\": {
      \"verified\": true,
      \"changed\": false,
      \"final_value\": \"summary\"
    }
  },
  \"calcuplate\": {
    \"analysis_type\": \"complete_meal\",
    \"items_detected\": [...],
    \"totals\": {
      \"calories\": number,
      \"protein_g\": number,
      \"carbs_g\": number,
      \"fat_g\": number,
      \"fiber_g\": number,
      \"sodium_mg\": number
    },
    \"confidence\": 85,
    \"data_source\": \"USDA database\"
  },
  \"insights\": [...],
  \"recommendations\": [...]
}

=== PRE-RESPONSE VALIDATION ===
Before outputting, verify ALL of these:
□ Every item has \"measurement_type\" field
□ Every \"beverage\" has beverage_type AND beverage_size
□ Every \"weighted_protein\" has protein_count AND protein_weight
□ Every \"count\" has numeric count value
□ Every \"portion\" has amount with units (cup/tbsp/oz)
□ No items have null/empty required fields
□ Chopped/mixed items use \"portion\" not \"count\"
□ Beverages specify type (regular vs diet for soda)

=== ABSOLUTE RULES ===
✗ NEVER omit measurement_type
✗ NEVER count chopped/diced items that are mixed in
✗ NEVER output beverage without specifying type
✗ NEVER skip visible items
✗ NEVER use count: 0 for visible items

✓ ALWAYS include measurement_type for every item
✓ ALWAYS scan entire image including background
✓ ALWAYS distinguish whole items (count) from chopped items (portion)
✓ ALWAYS specify beverage type (regular vs diet matters!)
✓ ALWAYS estimate protein weights

Focus on {$journeyConfig['focus']} using {$journeyConfig['tone']}.
Users are paying for accurate tracking - be thorough and precise.";

    $userPrompt = "Time: $time
Context: $notes
Symptoms: $symptoms

Analyze this meal photo for automatic nutritional logging with focus on {$journeyConfig['focus']}.

CRITICAL REMINDER: EVERY item MUST have \"measurement_type\" field. No exceptions.";

    $messages = [
        [
            'role' => 'system',
            'content' => $systemPrompt
        ],
        [
            'role' => 'user',
            'content' => [
                [
                    'type' => 'text',
                    'text' => $userPrompt
                ],
                [
                    'type' => 'image_url',
                    'image_url' => [
                        'url' => $base64Image,
                        'detail' => 'high'
                    ]
                ]
            ]
        ]
    ];

    error_log("QuietGo CalcuPlate: Making API call with v3.1 prompt");
    $response = makeOpenAIRequest($messages, OPENAI_VISION_MODEL, 1500);

    error_log("QuietGo CalcuPlate: Response received, has error: " . (isset($response['error']) ? 'YES' : 'NO'));

    if (isset($response['error'])) {
        throw new Exception($response['error']);
    }

    $aiContent = $response['choices'][0]['message']['content'];

    // Strip markdown code blocks if present
$aiContent = preg_replace('/^```json\s*/m', '', $aiContent);
$aiContent = preg_replace('/\s*```$/m', '', $aiContent);
$aiContent = trim($aiContent);

    $analysisData = json_decode($aiContent, true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        error_log("QuietGo CalcuPlate JSON Error: " . json_last_error_msg());
        error_log("AI Response (first 500 chars): " . substr($aiContent, 0, 500));
        throw new Exception('Invalid CalcuPlate response format');
    }

    // Check if AI detected non-food content
    if (isset($analysisData['error']) && $analysisData['error'] === 'not_food') {
        error_log("QuietGo CalcuPlate: Non-food image detected");
        throw new Exception('This doesn\'t appear to be a meal photo. Please upload a photo of food, or use the Stool or Symptom upload options for other types of health tracking.');
    }

    // Initialize debug info
    $debugInfo = [
        'validation_status' => '',
        'validation_errors' => [],
        'transformation_ran' => false,
        'transformation_log' => []
    ];

    // VALIDATE FORMAT
    $validation = validateCalcuPlateFormat($analysisData);

    if (!$validation['valid']) {
        $debugInfo['validation_status'] = 'FAILED';
        $debugInfo['validation_errors'] = $validation['errors'];

        error_log("QuietGo CalcuPlate: Format validation FAILED");
        foreach ($validation['errors'] as $error) {
            error_log("  - Validation Error: $error");
        }

        // Try to transform legacy format
        error_log("QuietGo CalcuPlate: Attempting format transformation...");
        $debugInfo['transformation_ran'] = true;

        list($analysisData, $transformLog) = transformLegacyFormat($analysisData);
        $debugInfo['transformation_log'] = $transformLog;

        // Re-validate after transformation
        $validation = validateCalcuPlateFormat($analysisData);
        if (!$validation['valid']) {
            error_log("QuietGo CalcuPlate: Transformation failed, still has errors");
            $debugInfo['validation_status'] = 'FAILED (even after transformation)';
            // Continue anyway - UI will handle unknown types
        } else {
            error_log("QuietGo CalcuPlate: Transformation successful!");
            $debugInfo['validation_status'] = 'PASSED (after transformation)';
        }
    } else {
        $debugInfo['validation_status'] = 'PASSED';
        error_log("QuietGo CalcuPlate: Format validation PASSED");
    }

    // Add debug info to response (visible in browser console)
    $analysisData['_debug'] = $debugInfo;

    // Log detection details
    if (isset($analysisData['pass_1_detection'])) {
        error_log("QuietGo CalcuPlate v3.1 Detection Complete:");
        foreach ($analysisData['pass_1_detection'] as $itemName => $itemData) {
            $type = $itemData['measurement_type'] ?? 'MISSING';
            error_log("  - $itemName: type=$type");

            switch ($type) {
                case 'beverage':
                    $bType = $itemData['beverage_type'] ?? 'MISSING';
                    $bSize = $itemData['beverage_size'] ?? 'MISSING';
                    error_log("    → $bType $bSize");
                    break;
                case 'weighted_protein':
                    $pCount = $itemData['protein_count'] ?? 'MISSING';
                    $pWeight = $itemData['protein_weight'] ?? 'MISSING';
                    error_log("    → $pCount piece(s), $pWeight");
                    break;
                case 'count':
                    $count = $itemData['count'] ?? 'MISSING';
                    error_log("    → $count items");
                    break;
                case 'portion':
                    $amount = $itemData['amount'] ?? 'MISSING';
                    error_log("    → $amount");
                    break;
                default:
                    error_log("    → UNKNOWN TYPE - transformation may be needed");
                    break;
            }
        }
    }

    // Log nutrition totals
    if (isset($analysisData['calcuplate']['totals'])) {
        $totals = $analysisData['calcuplate']['totals'];
        error_log("QuietGo CalcuPlate Nutrition:");
        error_log("  - Calories: {$totals['calories']}");
        error_log("  - Protein: {$totals['protein_g']}g");
        error_log("  - Carbs: {$totals['carbs_g']}g");
        error_log("  - Fat: {$totals['fat_g']}g");
    }

    // Ensure backward compatibility with UI
    if (isset($analysisData['calcuplate'])) {
        // Make sure legacy fields exist for UI compatibility
        if (!isset($analysisData['calcuplate']['auto_logged'])) {
            $analysisData['calcuplate']['auto_logged'] = true;
        }

        // Convert new totals format to legacy macros format if needed
        if (isset($analysisData['calcuplate']['totals']) && !isset($analysisData['calcuplate']['macros'])) {
            $totals = $analysisData['calcuplate']['totals'];
            $analysisData['calcuplate']['macros'] = [
                'protein' => $totals['protein_g'] . 'g',
                'carbs' => $totals['carbs_g'] . 'g',
                'fat' => $totals['fat_g'] . 'g',
                'fiber' => ($totals['fiber_g'] ?? 0) . 'g',
                'sodium' => ($totals['sodium_mg'] ?? 0) . 'mg'
            ];
        }

        // Ensure total_calories exists for legacy UI
        if (!isset($analysisData['calcuplate']['total_calories']) && isset($analysisData['calcuplate']['totals']['calories'])) {
            $analysisData['calcuplate']['total_calories'] = $analysisData['calcuplate']['totals']['calories'];
        }

        // Build legacy foods_detected from items_detected if needed
        if (!isset($analysisData['calcuplate']['foods_detected']) && isset($analysisData['calcuplate']['items_detected'])) {
            $foods = [];
            foreach ($analysisData['calcuplate']['items_detected'] as $item) {
                // Handle both string and array formats
                if (is_array($item) && isset($item['item'])) {
                    $foods[] = $item['item'] . ' (' . $item['quantity'] . ')';
                } elseif (is_string($item)) {
                    $foods[] = $item;
                }
            }
            $analysisData['calcuplate']['foods_detected'] = $foods;
        }

        // Add default quality metrics if missing
        if (!isset($analysisData['calcuplate']['meal_quality_score'])) {
            $analysisData['calcuplate']['meal_quality_score'] = '7/10';
        }
        if (!isset($analysisData['calcuplate']['nutritional_completeness'])) {
            $analysisData['calcuplate']['nutritional_completeness'] = '75%';
        }
    }

    // Add journey-specific insights
    if (isset($_SESSION['hub_user']) && is_array($_SESSION['hub_user']) && isset($_SESSION['hub_user']['journey'])) {
        switch ($_SESSION['hub_user']['journey']) {
            case 'clinical':
                $analysisData['clinical_nutrition'] = 'Logged for symptom correlation analysis';
                break;
            case 'performance':
                $analysisData['performance_nutrition'] = 'Logged for training optimization';
                break;
            case 'best_life':
                $analysisData['wellness_nutrition'] = 'Logged for energy pattern analysis';
                break;
        }
    }

    // Map new insights field to legacy nutrition_insights if needed
    if (!isset($analysisData['nutrition_insights']) && isset($analysisData['insights'])) {
        $analysisData['nutrition_insights'] = $analysisData['insights'];
    }

    // Ensure recommendations exist
    if (!isset($analysisData['recommendations']) || empty($analysisData['recommendations'])) {
        $analysisData['recommendations'] = [
            'Stay hydrated with water between meals',
            'Consider adding more vegetables for fiber',
            'Track patterns over time for best insights'
        ];
    }

    $analysisData['timestamp'] = time();
    $analysisData['ai_model'] = OPENAI_VISION_MODEL . ' (v3.1)';

    return $analysisData;
}

/**
 * Analyze Symptom Photo for tracking
 */
function analyzeSymptomPhoto($imagePath, $journeyConfig, $symptoms, $time, $notes)
{
    $base64Image = encodeImageForOpenAI($imagePath);
    if (!$base64Image) {
        throw new Exception('Failed to process image for AI analysis');
    }

    $systemPrompt = "You are a health documentation AI that analyzes symptom photos for tracking purposes.

Analyze this symptom photo using {$journeyConfig['tone']} focused on {$journeyConfig['focus']}.

Respond ONLY with valid JSON:
{
    \"symptom_category\": \"category description\",
    \"severity_estimate\": \"mild/moderate/notable\",
    \"visual_characteristics\": [\"char1\", \"char2\", \"char3\"],
    \"confidence\": (70-90 number),
    \"tracking_recommendations\": [\"rec1\", \"rec2\", \"rec3\"],
    \"correlation_potential\": \"description\"
}

IMPORTANT: This is for documentation only, not medical diagnosis.";

    $userPrompt = "Time: $time
Reported symptoms: $symptoms
Notes: $notes

Document this symptom photo for pattern tracking.";

    $messages = [
        [
            'role' => 'system',
            'content' => $systemPrompt
        ],
        [
            'role' => 'user',
            'content' => [
                [
                    'type' => 'text',
                    'text' => $userPrompt
                ],
                [
                    'type' => 'image_url',
                    'image_url' => [
                        'url' => $base64Image,
                        'detail' => 'high'
                    ]
                ]
            ]
        ]
    ];

    $response = makeOpenAIRequest($messages, OPENAI_VISION_MODEL, 600);

    if (isset($response['error'])) {
        throw new Exception($response['error']);
    }

    $aiContent = $response['choices'][0]['message']['content'];

    // Strip markdown code blocks if present
    $aiContent = preg_replace('/^```json\s*/m', '', $aiContent);
    $aiContent = preg_replace('/\s*```$/m', '', $aiContent);
    $aiContent = trim($aiContent);

    $analysisData = json_decode($aiContent, true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        error_log("QuietGo Symptom Analysis JSON Error: " . json_last_error_msg());
        error_log("AI Response: " . $aiContent);
        throw new Exception('Invalid symptom analysis response format');
    }

    $analysisData['timestamp'] = time();
    $analysisData['ai_model'] = OPENAI_VISION_MODEL;
    $analysisData['reported_symptoms'] = $symptoms ?: null;

    return $analysisData;
}

/**
 * Handle Manual Meal Logging
 */
function handleManualMealLogging($postData, $user)
{
    // Include storage helper
    require_once __DIR__ . '/storage-helper.php';
    $storage = getQuietGoStorage();

    // Validate required fields
    $required_fields = ['meal_type', 'meal_time', 'portion_size', 'main_foods'];
    foreach ($required_fields as $field) {
        if (empty($postData[$field])) {
            return ['status' => 'error', 'message' => 'Please fill in all required fields: ' . str_replace('_', ' ', $field)];
        }
    }

    // Validate time format
    if (!preg_match('/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/', $postData['meal_time'])) {
        return ['status' => 'error', 'message' => 'Please enter a valid time in HH:MM format'];
    }

    // Prepare meal log data
    $mealData = [
        'timestamp' => time(),
        'datetime' => date('Y-m-d H:i:s'),
        'user_email' => $user['email'],
        'photo_filename' => $postData['photo_filename'] ?? null,
        'meal_type' => $postData['meal_type'],
        'meal_time' => $postData['meal_time'],
        'portion_size' => $postData['portion_size'],
        'main_foods' => $postData['main_foods'],
        'estimated_calories' => !empty($postData['estimated_calories']) ? intval($postData['estimated_calories']) : null,
        'protein_grams' => !empty($postData['protein_grams']) ? floatval($postData['protein_grams']) : null,
        'carb_grams' => !empty($postData['carb_grams']) ? floatval($postData['carb_grams']) : null,
        'fat_grams' => !empty($postData['fat_grams']) ? floatval($postData['fat_grams']) : null,
        'hunger_before' => $postData['hunger_before'] ?? null,
        'fullness_after' => $postData['fullness_after'] ?? null,
        'energy_level' => !empty($postData['energy_level']) ? intval($postData['energy_level']) : null,
        'meal_notes' => $postData['meal_notes'] ?? null,
        'user_journey' => $user['journey'] ?? 'best_life',
        'subscription_plan' => $user['subscription_plan']
    ];

    // Store the meal log
    $logPath = $storage->storeLog($user['email'], 'manual_meals', $mealData);

    if ($logPath) {
        return [
            'status' => 'success',
            'message' => 'Meal logged successfully! This data will be used for pattern analysis with your stool tracking.',
            'log_path' => $logPath,
            'meal_data' => $mealData
        ];
    } else {
        return ['status' => 'error', 'message' => 'Failed to save meal log. Please try again.'];
    }
}
?>
